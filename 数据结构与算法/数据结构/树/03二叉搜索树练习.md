# 练习

## 1.判断一个二叉树为完全二叉树

> 完全二叉树：从上到下，从左到右都有节点，不能出现空节点；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012204225400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIZ29nb2dvaGE=,size_16,color_FFFFFF,t_70#pic_center)

思路：**层序遍历二叉树**

`false`

1. root == null
2. left == null && right !== null

`true`

1. left !== null && right == null && 之后遍历的节点必须为叶子节点
2. left == null && right == null && 之后遍历的节点必须为叶子节点

结合层序遍历使用队列的方式

1. left !== null && right !== null 左右子节点入队





####  [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### 递归解法

> 深度优先遍历

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201009110031894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIZ29nb2dvaGE=,size_16,color_FFFFFF,t_70#pic_center)



思路：将每一层看作是一个queue，用`index`记录层次，每往更深层次遍历，`index`++，如果这一层不存在对应的queue，就新建一个，如果存在，就直接添加；

![5.jpg](https://pic.leetcode-cn.com/367726d56045ab65cd9bf34af1f4b98408dfa02669c0d2bb88b4aeb53143cf1f-5.jpg)



#### DFS

```js
var levelOrder = function(root) {
    return new Solution(root);
};

class Solution {
    constructor(root) {
        if (!root) {
            return [];
        }

        this.queue = [];
        this.dfs(root, 0);
        return this.list;
    }

    dfs(node, index) {
        if (!this.queue[index]) {
            this.queue[index] = [];
        }

        this.queue[index].push(node.val);

        if (node.left) {
            this.dfs(node.left, index + 1);
        }
        if (node.right) {
            this.dfs(node.right, index + 1);
        }
    }
}
```



### 广度优先遍历 BFS

![二叉树的层序遍历](https://pic.leetcode-cn.com/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg)

应用在层序遍历上，即是将二叉树进行分层，从左到右，从上到下遍历；

思路：

1. 创建一个**队列**，从根节点开始入队；
2. 根节点出队，访问根节点，将**根节点的左右子节点入队；**
3. 一直遍历，直到队列为空，即遍历到最后的叶子节点；

一开始的代码：

```js
var levelOrder = function (root) {
    if (!root) {
        return [];
    }

    let queue = [];
    let result = [];
    queue.push(root);

    while (queue.length) {
       let node = queue.pop();
       let list = [];
       list.push(node.element);
       result.push(list);

       if (node.left) {
           queue.push(node.left);
       }
       if (node.right) {
           queue.push(node.right);
       }
    }

    return result;
};
```



但是这样会有一个问题：

![BFS 遍历与层序遍历的输出结果不同](https://pic.leetcode-cn.com/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg)

输出的结果是一个二维数组，但是每个节点都单独形成了一个一维数组，因为每次循环都创建了新的list；

这里最难的问题就是如何对二叉树进行**分层**；

截取 BFS 遍历过程中的某个时刻：

![BFS 遍历中某个时刻队列的状态](https://pic.leetcode-cn.com/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg)

解决办法：先提前获取`queue`的length，一次性出队

```js
while (queue.length) {
    // 记录这一层节点的个数
    let size = queue.length;

    // 存放每一列的结果
    let list = [];

    // 让这一层节点的个数全部出队
    for (let i = 0; i < size; i++) {
        let node = queue.shift();
        list.push(node.element);

        if (node.left) {
            queue.push(node.left);
        }
        if (node.right) {
            queue.push(node.right);
        }
    }
    result.push(list);

}
```



### DFS BFS区别

![DFS 与 BFS 对比](https://pic.leetcode-cn.com/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif)





## 参考

https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/

