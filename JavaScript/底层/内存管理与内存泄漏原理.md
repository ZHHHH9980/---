# 内存

> C 语言提供了 `malloc()` 与 `free()` 等手动分配释放内存的API，使用定长数组也需要先声明数组长度int a[10]。

与这类语言不同，JavaScript不需要手动分配内存，声明并且定义一个变量，JavaScript Runtime会自动分配内存。



## 内存回收

内存生命周期

- 内存分配
- 内存使用
- 内存回收

```javascript
var a = {a: 1};	// 分配
console.log(a.a);	// 使用
```

当变量a不再被引用，就会被垃圾回收器（Garbage Collector）回收。

这是一种最简单的垃圾回收算法，即引用计数（Reference Counting），即清除所有**零引用的对象**。当然这也会带来一些问题。



比如循环引用

```javascript
var o = {};
var b = {};
o.a = b;
b.a = o;
```

o,b彼此互相引用，因此无法清除。



稍为复杂的算法即是所谓的标记-清除（Mark-Sweep）算法，其根据某个对象是否**可达**来判断某个对象是否可用。标记-清除算法会从某个根元素开始，譬如 window 对象开始，沿着引用树向下遍历，标记所有可达的对象为可用，并且清除其他未被标记的对象。

![img](https://user-gold-cdn.xitu.io/2017/11/3/955384f1bc65ed255756f9f7e8c1ef6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

而我们刚才的例子还是无法清除,因为windows对象都可达。

```javascript
var o = {};
var b = {};
o.a = b;
b.a = o;
```

如果这样改一下，就可以清除了

```javascript
function () {
    var o = {};
    var b = {};
    o.a = b;
    b.a = o;
}
```

如图蓝色部分

![img](https://images2018.cnblogs.com/blog/1043723/201712/1043723-20171204005622210-980252348.png)



> 这里用let应该也能解决这个问题，因为var会与window属性建立映射机制，而let并没有映射机制



## 内存泄漏原理

内存泄漏是指一块即实际不再需要了，但又不能回收的内存，直到浏览器进程结束。



## 内存泄漏的几种情况

- 循环引用
- 外部引用
- 其他引用



### 循环引用

我们经常给DOM对象添加一些自定义属性，JS对象也可能对DOM对象进行引用。

```javascript
var el = document.getElementById('a');
var obj = {data: 'xxx'};

el.data = obj;
obj.el = el;
```



### 外部引用(闭包)

```javascript
function Test()  
{  
    this.index = 1;
    window.setInterval(() =>{
        this.index += 1; 
    }, 1);  
}  
test = new Test(); // JS对象开启定时器不断分配内存
```

这个例子表面上看就是实例化Test，开启了一个定时器，实际上产生了window（外部）对函数内部的引用。即使test = null;手动清空test，这块内存依然存在。



解决方案

```javascript
function Test()  
{  
    this.index = 1;
    this.timer = window.setInterval(() =>{
        this.index += 1; 
    }, 1);  
}  
test = new Test();
test.timer = null;
```



### 内部引用

既然有外部引用就应该有内部引用，但是本人并不觉得是严格意义上的内存泄漏，只是顺带一提。

我们经常会使用 `setInterval` 来执行定时任务，很多的框架也提供了基于回调的异步执行机制；这可能会导致回调中声明了对于某个变量的依赖，譬如：

```javascript
var serverData = loadData();//《《《《
setInterval(function() {
    var renderer = document.getElementById('renderer');
    if(renderer) {
        renderer.innerHTML = JSON.stringify(serverData);//《《《《
    }
}, 5000); //This will be executed every ~5 seconds.
```

定时器保有对于 serverData 变量的引用，如果我们不手动清除定时器话，那么该变量也就会一直可达，不被回收。





### 其他引用

即使removeChild,这个dom对象依然存在，因为有其他对象还有引用。

```javascript
var elements = {
    image: document.getElementById('image')
};
function removeImage() {
    document.body.removeChild(document.getElementById('image'));
};
removeImage();
```



## 总结

内存回收常见有两种算法，一种是计数算法，即记下零引用的对象，清除。

还有一种比较复杂，是主流浏览器使用的算法，即标记-清除法，从最顶层对象开始往下查找，不可到达的对象就会被清除。



内存泄漏往往是一些难以察觉的**引用**导致了应该被释放的内存依然被占用。